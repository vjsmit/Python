Videos to revise: 44


Methods:
    Methods are essentially functions built into objects.
    Methods are in the form:
      object.method(arg1,arg2,etc...)
    Methods for list are:
      append
      count: count the number of occurrences of an element in a list.
      extend
      insert
      pop
      remove
      reverse
      sort
 Functions:
    A function is a useful device that groups together a set of statements so they can be run more than once. 
    They can also let us specify parameters that can serve as inputs to the functions.
    functions allow us to not have to repeatedly write the same code again and again.
    The function will allow you to call the same block of code without having to write it multiple times.
Function Topics:
    def keyword
    simple example of a function
    calling a function with ()
    accepting parameters
    print versus return
    adding in logic inside a function
    multiple returns inside a function
    adding in loops inside a function
    tuple unpacking
    interactions between functions
    

def name_of_function(arg1,arg2):
    '''
    This is where the function's Document String (docstring) goes.
    When you call help() on your function it will be printed out.
    '''
    # Do stuff here
    # Return desired result
    
Using return
   If we actually want to save the resulting variable we need to use the return keyword.
   Return keyword we use to send back the result of the function instead of just printing it out.
   return allows us to assign the output of the function to a new variable
   
   
What is the difference between return and print?"
  The return keyword allows us to actually save the result of the output of a function as a variable.
  The print() function simply displays the output to you, but doesn't save it for future use.
 
Empty placeholder list
    Its very common at top of function call if we intend on returning something, and if we dont hv it defined as an argument then we define it up as some sort of place holder
    
Return all even numbers in a list
    
Returning Tuples for Unpacking

Interactions between functions


map function
The map function allows us to "map" a function to an iterable object. 
That is to say you can quickly call the same function to every item in an iterable, such as a list.
e.g.:

def square(num):
    return num**2
    
my_nums = [1,2,3,4,5]

map(square,my_nums)

# To get the results, either iterate through map() 
# or just cast to a list
list(map(square,my_nums))

Filter:
It will filter based on the function's condition

def check_even(num):
    return num % 2 == 0
nums = [0,1,2,3,4,5,6,7,8,9,10]
list(filter(check_even,nums))
[0, 2, 4, 6, 8, 10]

lambda expression¶
lambda expressions allow us to create "anonymous" functions. 
This basically means we can quickly make ad-hoc functions without needing to properly define a function using def.
since some functionality that we intend to use only 1 time boz of this we dont use any name nor use def keyword
Instead of function name and def keyword we use lambda keyword
we dont use return keyword also as by default it will return what is on other side of colon.
e.g. square = lambda num: num**2


Nested Statements and Scope:
When we create a variable name in Python the name is stored in a name-space.
Variable names also have a scope, the scope determines the visibility of that variable name to other parts of your code.
Python has a set of rules it follows to decide what variables we are referencing in our code. Lets break down the rules:
1)Name assignments will create or change local names by default.
2)Name references search (at most) four scopes, these are:
  local
  enclosing functions
  global
  built-in
3)Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes.

LEGB Rule:

L: Local — Names assigned in any way within a function (def or lambda), and not declared global in that function.

E: Enclosing function locals — Names in the local scope of any and all enclosing functions (def or lambda), from inner to outer.

G: Global (module) — Names assigned at the top-level of a module file, or declared global in a def within the file.

B: Built-in (Python) — Names preassigned in the built-in names module : open, range, SyntaxError,...

When we declare variables inside of a function definition, these variable names have a scope local to this function.
For local reassignment, its scope wont be able to extend outside to another level.

In case we want global variable to be changed to local variable:
        Inside a function we declare global keyword and then x instead of passing it as a parameter.
        Better option:
        We should take it as a parameter. Do the reassignment and then return the reassignment.
        
        
.isupper() & .islower() ---To check if the word starts with caps or small letter
.replace('a','b') -------- To replace a with b

Pangram:
Pangrams are words or sentences containing every letter of the alphabet at least once.
For example : "The quick brown fox jumps over the lazy dog"

import string
>>> string.ascii_lowercase
'abcdefghijklmnopqrstuvwxyz'
>>> list(string.ascii_lowercase) ---if we want in list

>>> help(string) # on Python 3
....
DATA
    ascii_letters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    ascii_lowercase = 'abcdefghijklmnopqrstuvwxyz'
    ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    digits = '0123456789'
    hexdigits = '0123456789abcdefABCDEF'
    octdigits = '01234567'
    printable = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\x0b\x0c'
    punctuation = '!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'
    whitespace = ' \t\n\r\x0b\x0c'
