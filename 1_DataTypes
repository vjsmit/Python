Integers: int (whole no. 3,100,500)
Floating Point: float (Decimal point)
strings: str ("Alphabets")
    Str are ordered seq it means we can use indexing (single char) and slicing (slice of string)[start:stop:step] to grab subsections of the string.
    \n and \t for new line & tab respectively
    Str are immutable
  Print formating with strings(interpolation):
    to inject a variable into our string
    1) .format mmethod:
            'string here {} then also {}'.format('something1', 'something2')
             Field widths and float precision: 'string here {value:width.precision f}'.format('value')
    2) f-strings:
              name:Smit
              print(f"He said his name is {name}.")
              print(f"He said his name is {name!r}")  !r to get str representation.
              Where with the .format() method we  see {value:10.4f}, with f-strings this can become {value:{10}.{6}} 
              Note that with f-strings, precision refers to the total number of digits, not just those following the decimal. 
              Unfortunately, f-strings do not pad to the right of the decimal, even if precision allows it
              Another way:
                        print(f"My 10 character, four decimal number is:{num:10.4f}")
              
Lists: lst
        Lists are ordered seq that can hold a variety of object types. Uses [] and , to separate objects.
        Supports indexing an slicing.
        It can be nested and also have variety of methods that can be called off of them.
        Change of objects allowed in Lists.
        Various methods are:
            .append() , .pop()- to remove last object from list
            .sort() , .reverse()
            
            
Dictionaries: dict, Unordered key:value pairs. {"mykey":"value"}
        Unordered mappings for storing objects.
        We have key:value pair.
        In Dict objects retrieved by key name. Unordered and cant be sorted.
        

        In list objects retrieved by location. Ordered seqn can be indexed and sliced.
        my_dict = {'key1':'value1', 'key2':'value2'}
        my_dict['key1'] -----to retrieve value 
        my_dict.keys() = to retrieve keys
        my_dict.values() = to retrieve values 
        my_dict.items()  = to retrieve items
        
Tuples: tup, (ordered immutable seqn of objects) (10,"hello",10.0)
         Similar to lists with one key diff of immutabilty. Tuple obj doesnt support item assignment.
         uses parenthesis: (1,2,3).
         2 fn: count and index
         

Booleans: bool, Logical value True or False

*Variables Rules:
  cant start with a no.
  No spaces bw name
  cant use another specila symbol but _
  lowercase generally
  avaid using name that hv special meaning like int/float
  
*Python uses dynamic typing means that we can re-assign variables to diff data types. Other languages are statically typed.

Simple I/O
%%writefile filename.txt
contents to write
myfile = open('filename.txt')
pwd - print working directory
myfile.read()
myfile.seek(0)
myfile.readlines()
myfile.close()
with open ('filename.txt') as variable_name:
    contents = variable_name.read() ##Now no need to close the file
contents

read/wr/append the file
*To read-
with open ('filename.txt', mode='r') as variable_name:
    print(variable_name.read())
  
*To append-
with open('filename.txt', mode='a') as variable_name:
    variable_name.write('\nNew line added')
with open ('filename.txt', mode='r') as variable_name:
    print(variable_name.read())
    
*To write(creating new file and adding contents there)-
with open('newfilename.txt', mode='w') as variable_name:
    variable_name.write('Creating file and adding this line')
with open ('newfilename.txt', mode='r') as variable_name
    print(variable_name.read())
    
    
mode='r' is read only
     'w' is write only (overwrites file or create new)
     'a' is append only
     'r+' is reading and writing
     'w+' is writing and reading
